package com.thelogicmaster.clearwing;

import com.thelogicmaster.clearwing.bytecode.Instruction;
import com.thelogicmaster.clearwing.bytecode.LabelInstruction;
import com.thelogicmaster.clearwing.bytecode.TryInstruction;
import org.objectweb.asm.Handle;
import org.objectweb.asm.Label;
import org.objectweb.asm.Opcodes;

import java.util.*;
import java.util.function.Function;

public class BytecodeMethod {

	private final BytecodeClass clazz;
	private final String name;
	private final String originalName;
	private final int access;
	private final String desc;
	private final String signature;
	private final MethodSignature methodType;
	private final String[] exceptions;

	private final ArrayList<Instruction> instructions = new ArrayList<>();
	private final ArrayList<TryInstruction> tryCatchBlocks = new ArrayList<>();
	private final ArrayList<BytecodeAnnotation> annotations = new ArrayList<>();
	private int stackSize;
	private int localCount;
	private int tryCatchBypasses;
	private final HashMap<Integer, TypeVariants> knownLocals = new HashMap<>();
	private final HashMap<Label, Integer> labelIds = new HashMap<>();
	private int labelCount;
	private boolean intrinsic;
	private boolean generated;

	public BytecodeMethod (BytecodeClass clazz, String name, int access, String desc, String signature, String[] exceptions) {
		this.clazz = clazz;
		this.originalName = name;
		this.methodType = new MethodSignature(name, desc);
		this.access = access;
		this.name = Utils.sanitizeMethod(name, methodType, isStatic(), false);
		this.desc = desc;
		this.signature = signature;
		this.exceptions = exceptions;
	}

	public void addInstruction(Instruction instruction) {
		instructions.add(instruction);
	}

	public boolean isStatic() {
		return (access & Opcodes.ACC_STATIC) == Opcodes.ACC_STATIC;
	}

	public boolean isNative() {
		return (access & Opcodes.ACC_NATIVE) == Opcodes.ACC_NATIVE;
	}

	public boolean isAbstract() {
		return (access & Opcodes.ACC_ABSTRACT) == Opcodes.ACC_ABSTRACT;
	}

	public boolean isSynchronized() {
		return (access & Opcodes.ACC_SYNCHRONIZED) == Opcodes.ACC_SYNCHRONIZED;
	}

	public boolean isMain() {
		return isStatic() && (access & Opcodes.ACC_PUBLIC) == Opcodes.ACC_PUBLIC && originalName.equals("main") && "([Ljava/lang/String;)V".equals(desc);
	}

	public boolean hasBody() {
		return !isNative() && !isAbstract();
	}

	/**
	 * Collects and returns all class dependencies (Sanitized class names)
	 */
	public void collectDependencies(Set<String> dependencies, Map<String, BytecodeClass> classMap) {
		for (Instruction instruction: instructions)
			instruction.collectDependencies(dependencies);
		if (methodType.getReturnType().getComponentType() == TypeVariants.OBJECT)
			dependencies.add(methodType.getReturnType().getRegistryTypeName());
		for (JavaType type: methodType.getParamTypes())
			if (type.getComponentType() == TypeVariants.OBJECT)
				dependencies.add(type.getRegistryTypeName());
		for (BytecodeAnnotation annotation: annotations)
			annotation.collectDependencies(dependencies, classMap);
	}

	/**
	 * Allocates a new try-catch bypass and returns the index
	 */
	public int allocateTryCatchBypass() {
		return tryCatchBypasses++;
	}

	public int getTryCatchBypasses() {
		return tryCatchBypasses;
	}

	public int getLabelId(Label label) {
		if (label == null)
			return -1;
		if (labelIds.containsKey(label))
			return labelIds.get(label);
		labelIds.put(label, labelCount++);
		return labelIds.get(label);
	}

	/**
	 * Mark this method as intrinsic so that it will not generate the function body
	 */
	public void markIntrinsic() {
		intrinsic = true;
	}

	public boolean isIntrinsic() {
		return intrinsic;
	}

	/**
	 * Mark this method as transpiler generated to avoid unneeded generation
	 */
	public void markGenerated() {
		generated = true;
	}

	/**
	 * Whether this method was generated by the transpiler and doesn't need a stack and such
	 */
	public boolean isGenerated() {
		return generated;
	}

	/**
	 * Finds the first instruction of a given type and returns the index, throwing an exception if one isn't found
	 */
	public <T extends Instruction> int findInstruction(Class<T> clazz) {
		return findInstruction(0, instructions.size(), true, clazz);
	}

	/**
	 * Finds the first instruction of a given type in range [start, end) and returns the index
	 * Throws an exception if one isn't found and required is set
	 */
	public <T extends Instruction> int findInstruction(int start, int end, boolean required, Class<T> clazz) {
		return findInstruction(start, end, required, instr -> clazz.isAssignableFrom(instr.getClass()));
	}

	/**
	 * Finds the first instruction matching the predicate and returns the index, throwing an exception if one isn't found
	 */
	public int findInstruction(Function<Instruction, Boolean> func) {
		return findInstruction(0, instructions.size(), true, func);
	}

	/**
	 * Finds the index of the label instruction corresponding to `label`, throwing an exception if not found
	 */
	public int findLabelInstruction(int label) {
		return findInstruction(instr -> instr instanceof LabelInstruction && ((LabelInstruction) instr).getLabel() == label);
	}

	/**
	 * Finds the first instruction matching the predicate in range [start, end) and returns the index
	 * Throws an exception if one isn't found and required is set
	 */
	public int findInstruction(int start, int end, boolean required, Function<Instruction, Boolean> func) {
		for (int i = start; i < end; i++)
			if (func.apply(instructions.get(i)))
				return i;
		if (required)
			throw new TranspilerException("Failed to find instruction");
		return -1;
	}

	public void addAnnotation(BytecodeAnnotation annotation) {
		annotations.add(annotation);
	}

	public ArrayList<BytecodeAnnotation> getAnnotations() {
		return annotations;
	}

	public boolean isFinalizer() {
		return "M_finalize".equals(name);
	}

	public boolean isStaticInitializer() {
		return originalName.equals("<clinit>");
	}

	public boolean isConstructor() {
		return originalName.equals("<init>");
	}

	public BytecodeClass getOwner () {
		return clazz;
	}

	public String getName () {
		return name;
	}

	public String getOriginalName () {
		return originalName;
	}

	public int getAccess () {
		return access;
	}

	public String getDesc () {
		return desc;
	}

	public String getGenericSignature() {
		return signature;
	}

	public String[] getExceptions () {
		return exceptions;
	}

	public List<Instruction> getInstructions () {
		return instructions;
	}

	public Map<Integer, TypeVariants> getKnownLocals() {
		return knownLocals;
	}

	public boolean isLocalKnown(int local) {
		return knownLocals.get(local) != null;
	}

	public void setStackSize(int stackSize, int localCount) {
		this.stackSize = stackSize;
		this.localCount = localCount;
	}

	public int getStackSize() {
		return stackSize;
	}

	public int getLocalCount() {
		return localCount;
	}

	public void addTryCatch(TryInstruction tryInstruction) {
		tryCatchBlocks.add(tryInstruction);
	}

	public List<TryInstruction> getTryCatchBlocks() {
		return tryCatchBlocks;
	}

	public MethodSignature getSignature() {
		return methodType;
	}

	@Override
	public String toString() {
		return clazz + "." + name;
	}
}
